# Docker进程监控问题分析报告

## 当前状态

### ✅ 已实现的功能
1. **Docker容器级别监控** - 可以监控容器的整体资源使用情况
2. **系统进程监控** - 可以监控宿主机上的进程
3. **统一数据格式** - Docker容器和系统进程数据格式统一

### ❌ 发现的问题

## 问题1: 容器内进程监控缺失

**现象:**
- 我们的监控只能看到容器级别的指标（如docker:immich_server）
- 无法监控到容器内部的具体进程（如容器内的Nginx、Postgres、Python应用等）

**原因分析:**
1. gopsutil库的`process.Processes()`函数只能获取宿主机上的进程
2. 容器内的进程在宿主机上表现为不同的进程ID和命名空间
3. 容器使用独立的PID namespace，默认情况下宿主机无法看到容器内的进程

**实际状况:**
- 宿主机上可以看到一些容器进程（如postgres进程显示连接来自容器IP）
- 但大部分容器内进程对宿主机是不可见的
- 我们的监控只能捕获到容器级别的资源使用情况

## 问题2: Docker SDK数据收集不完整

**当前实现:**
```go
// 只能获取容器级别的统计信息
stats, err := dm.client.ContainerStats(ctx, container.ID, false)
```

**缺失的信息:**
- 容器内具体进程列表
- 各进程的详细资源使用情况
- 进程间的资源分配关系

## 问题3: 容器内进程发现机制缺失

**当前问题:**
- 没有进入容器内部获取进程列表的机制
- 无法区分容器内不同进程的资源贡献
- 监控粒度不够细，无法进行容器内性能分析

## 需要解决的核心问题

### 1. 容器内进程可见性问题
**技术挑战:**
- 需要跨越PID namespace边界
- 需要容器内部进程发现机制
- 需要权限和安全性考虑

### 2. 数据收集架构问题
**当前架构局限:**
- 单一数据源（gopsutil + Docker SDK）
- 缺乏容器内进程监控能力
- 数据模型不够灵活

### 3. 性能和开销问题
**潜在问题:**
- 频繁进入容器执行命令可能影响性能
- 容器内进程监控增加系统开销
- 需要平衡监控精度和性能影响

## 解决方案思考

### 方案A: 使用docker exec获取容器内进程
**优点:**
- 实现相对简单
- 可以获取完整的容器内进程列表
- 利用现有Docker SDK

**缺点:**
- 性能开销较大
- 需要容器内有ps等工具
- 频繁exec可能影响容器性能

### 方案B: 使用cgroups和namespace信息
**优点:**
- 性能开销小
- 不需要进入容器
- 可以获取底层资源数据

**缺点:**
- 实现复杂
- 需要深入了解Linux内核机制
- 进程名信息可能不完整

### 方案C: 集成专门的容器监控工具
**优点:**
- 功能完整
- 成熟的解决方案
- 支持多种容器运行时

**缺点:**
- 增加依赖复杂度
- 可能违反"简单"原则
- 需要额外的部署和配置

## 建议

根据Dave Cheney的"简单优先"原则，我建议：

1. **短期目标**: 保持当前的容器级别监控，这是实用且稳定的方案
2. **中期目标**: 考虑添加轻量级的容器内进程监控
3. **长期目标**: 根据实际需求决定是否需要更复杂的监控能力

当前实现已经满足了大部分监控需求，容器级别的监控对于资源管理和问题排查已经足够。